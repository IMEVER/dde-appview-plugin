// SPDX-FileCopyrightText: 2022 UnionTech Software Technology Co., Ltd.
//
// SPDX-License-Identifier: GPL-3.0-or-later

#include "dfilesystemmodel.h"
#include "dabstractfileinfo.h"
#include "dfileservices.h"
#include "dabstractfilewatcher.h"
#include "dfmstyleditemdelegate.h"
#include "dfmapplication.h"
#include "views/dfileview.h"
#include "dfmstandardpaths.h"

#include "app/define.h"
#include "app/filesignalmanager.h"
#include "singleton.h"

#include "controllers/vaultcontroller.h"
#include "controllers/jobcontroller.h"
#include "controllers/appcontroller.h"
#include "shutil/desktopfile.h"
//处理自动整理的路径问题
#include "controllers/mergeddesktopcontroller.h"
#include "shutil/dfmfilelistfile.h"
#include "dfilesystemmodel_p.h"
#include "dfmsettings.h"

#include <memory>
#include <QList>
#include <QMap>
#include <QDebug>
#include <QMimeData>
#include <QSharedPointer>
#include <QAbstractItemView>
#include <QtConcurrent/QtConcurrent>
#include <QtGlobal>

#define fileService DFileService::instance()
#define DEFAULT_COLUMN_COUNT 0

static int FindInsertPosInOrderList(const FileSystemNodePointer &needNode,
        const QList<FileSystemNodePointer> &list, const DAbstractFileInfo::CompareFunction &sortFun,
        const Qt::SortOrder &order){
    if (!sortFun)
        return list.count();
    int begin = 0;
    int end = list.count();
    int row = (begin + end)/2;
    // 先找到文件还是目录
    forever {
        if (begin == end)
            break;

        const FileSystemNodePointer &node = list.at(row);
        if (!sortFun(needNode->fileInfo->m_fileInfo, node->fileInfo->m_fileInfo, order, DFMApplication::appAttribute(DFMApplication::AA_FileAndDirMixedSort).toBool())) {
            begin = row;
            row = (end + begin + 1) / 2;
            if (row >= end)
                break;
        } else {
            end = row;
            row = (end + begin) / 2;
        }
    }
    return row;
}

class AppFileInfo : public QObject {
public:
    AppFileInfo(DUrl url, QString file, QObject *parent) :m_url(url), m_file(file), m_fileInfo(0), QObject(parent) {
        m_fileInfo = fileService->createFileInfo(parent, DUrl(file));
    }

private:
    DUrl m_url;
    QString m_file;
    DAbstractFileInfoPointer m_fileInfo;

    friend class FileSystemModel;
};

FileNode::FileNode(FileNode *parent,
                   const AppFileInfoPointer &info,
                   FileSystemModel *dFileSystemModel,
                   QReadWriteLock *lock)
        : fileInfo(info)
        , parent(parent)
        , m_dFileSystemModel(dFileSystemModel)
        , rwLock(lock)
{

}

FileNode::~FileNode()
{
    visibleChildren.clear();
    children.clear();
}

QVariant FileNode::dataByRole(int role)
{
    DAbstractFileInfo &info = fileInfo->m_fileInfo;
    using Role = FileSystemModel::Roles;

    switch (role)
    {
    case Role::FilePathRole:
        return info->absoluteFilePath();
    case Role::FileDisplayNameRole:
        return info->fileDisplayName();
    case Role::FileNameRole:
        return info->fileName();
    case Role::FileNameOfRenameRole:
        return info->fileNameOfRename();
    case Role::FileBaseNameRole:
        return info->baseName();
    case Role::FileBaseNameOfRenameRole:
        return info->baseNameOfRename();
    case Role::FileSuffixRole:
        return info->suffix();
    case Role::FileSuffixOfRenameRole:
        return info->suffixOfRename();
    case Qt::TextAlignmentRole:
        return Qt::AlignVCenter;
    case Role::FileLastModifiedRole:
        return info->lastModifiedDisplayName();
    case Role::FileLastModifiedDateTimeRole:
        return info->lastModified();
    case Role::FileSizeRole:
        return info->sizeDisplayName();
    case Role::FileSizeInKiloByteRole:
        return info->size();
    case Role::FileMimeTypeRole:
        return info->mimeTypeDisplayName();
    case Role::FileCreatedRole:
        return info->createdDisplayName();
    case Role::FilePinyinName:
        return info->fileDisplayPinyinName();
    case Role::ExtraProperties:
        return info->extraProperties();
    case Role::FileLastReadDateTimeRole:
        return info->lastRead();
    case Role::FileCreatedDateTimeRole:
        return info->created();
    default: {
        return QVariant();
        }
    }
}

void FileNode::sortAllChildren(const DAbstractFileInfo::CompareFunction &sortFun, const Qt::SortOrder &order) {
    if (!sortFun || visibleChildren.isEmpty())
        return;
    QList<FileSystemNodePointer> sortList;
    int row = 0;
    rwLock->lockForWrite();
    for (const auto & needNode : visibleChildren) {
        row = FindInsertPosInOrderList(needNode, sortList, sortFun, order);
        sortList.insert(row, needNode);
    }
    visibleChildren = sortList;
    rwLock->unlock();
}

void FileNode::noLockInsertChildren(int index, const DUrl &url, const FileSystemNodePointer &node)
{
    // fix bug 105595
    if (!children.contains(url)) {
        children[url] = node;
        visibleChildren.insert(index, node);
    }
}

void FileNode::insertChildren(int index, const DUrl &url, const FileSystemNodePointer &node)
{
    rwLock->lockForWrite();
    noLockInsertChildren(index, url, node);
    rwLock->unlock();
}

int FileNode::insertChildren(const DUrl &url, const FileSystemNodePointer &needNode, const DAbstractFileInfo::CompareFunction &sortFun, const Qt::SortOrder &order, const bool &isInsert)
{
    rwLock->lockForWrite();
    int row = 0;
    if (!children.contains(url)) {
        if (!sortFun) {
            row = visibleChildren.count();
            if (isInsert)
                noLockAppendChildren(url, needNode);
        } else {
            row = FindInsertPosInOrderList(needNode, visibleChildren, sortFun, order);
            if (isInsert)
                noLockInsertChildren(row, url, needNode);
        }
    }
    rwLock->unlock();
    return row;
}

void FileNode::noLockAppendChildren(const DUrl &url, const FileSystemNodePointer &node)
{
    // fix bug 105595
    if (!children.contains(url)) {
        children[url] = node;
        visibleChildren.append(node);
    }
}

void FileNode::appendChildren(const DUrl &url, const FileSystemNodePointer &node)
{
    rwLock->lockForWrite();
    noLockAppendChildren(url, node);
    rwLock->unlock();
}

FileSystemNodePointer FileNode::getNodeByUrl(const DUrl &url)
{
    rwLock->lockForRead();
    FileSystemNodePointer node = children.value(url);
    rwLock->unlock();

    return node;
}

FileSystemNodePointer FileNode::getNodeByIndex(int index)
{
    rwLock->lockForRead();
    FileSystemNodePointer node = visibleChildren.value(index);
    rwLock->unlock();
    return node;
}

FileSystemNodePointer FileNode::takeNodeByUrl(const DUrl &url)
{
    rwLock->lockForWrite();
    FileSystemNodePointer node = children.take(url);
    visibleChildren.removeOne(node);
    rwLock->unlock();

    return node;
}

FileSystemNodePointer FileNode::takeNodeByIndex(const int index)
{
    rwLock->lockForWrite();
    FileSystemNodePointer node;
    if (index >= 0 && visibleChildren.size() > index) {
        node = visibleChildren.takeAt(index);
        children.remove(node->fileInfo->m_url);
    } else {
        qWarning() << "index [" << index << "] out of range [" << visibleChildren.size() << "]";
    }
    rwLock->unlock();

    return node;
}

int FileNode::indexOfChild(const FileSystemNodePointer &node)
{
    rwLock->lockForRead();
    int index = visibleChildren.indexOf(node);
    rwLock->unlock();

    return index;
}

int FileNode::indexOfChild(const DUrl &url)
{
    rwLock->lockForRead();
    const FileSystemNodePointer &node = children.value(url);
    int index = visibleChildren.indexOf(node);
    rwLock->unlock();

    return index;
}

int FileNode::childrenCount()
{
    QReadLocker rl(rwLock);
    return visibleChildren.count();
}

QList<FileSystemNodePointer> FileNode::getChildrenList() const
{
    QList<FileSystemNodePointer> list;
    rwLock->lockForRead();
    list = visibleChildren;
    rwLock->unlock();

    return list;
}

DUrlList FileNode::getChildrenUrlList()
{
    DUrlList list;
    rwLock->lockForRead();
    list.reserve(visibleChildren.size());

    for (const FileSystemNodePointer &node : visibleChildren)
        list << node->fileInfo->m_url;

    rwLock->unlock();
    return list;
}

QHash<DUrl, FileSystemNodePointer> FileNode::getChildrenMap() const
{
    QHash<DUrl, FileSystemNodePointer> map;
    rwLock->lockForRead();
    map = children;
    rwLock->unlock();

    return map;
}

void FileNode::setChildrenList(const QList<FileSystemNodePointer> &list)
{
    rwLock->lockForWrite();
    visibleChildren = list;

    rwLock->unlock();
}

void FileNode::setChildrenMap(const QHash<DUrl, FileSystemNodePointer> &map)
{
    rwLock->lockForWrite();
    children = map;
    rwLock->unlock();
}

void FileNode::clearChildren()
{
    rwLock->lockForWrite();
    visibleChildren.clear();
    children.clear();
    rwLock->unlock();
}

bool FileNode::childContains(const DUrl &url)
{
    QReadLocker rl(rwLock);
    return children.contains(url);
}


void FileNode::addFileSystemNode(const FileSystemNodePointer &node)
{
    if (nullptr != node->parent) {
        QString url = node->fileInfo->m_file;
        rwLock->lockForWrite();
        if (!m_dFileSystemModel->m_allFileSystemNodes.contains(url)) {
            m_dFileSystemModel->m_allFileSystemNodes[url] = node;
        }
        rwLock->unlock();
    }
}

void FileNode::removeFileSystemNode(const FileSystemNodePointer &node)
{
    if (nullptr != node->parent) {
        QString url = node->fileInfo->m_file;
        rwLock->lockForWrite();
        qDebug() << m_dFileSystemModel->m_allFileSystemNodes[url];
        m_dFileSystemModel->m_allFileSystemNodes.remove(url);
        rwLock->unlock();
    }
}

const FileSystemNodePointer FileNode::getFileSystemNode(FileNode *parent)
{
    if (nullptr == parent) {
        return FileSystemNodePointer();
    }

    QString url = parent->fileInfo->m_file;

    rwLock->lockForWrite();
    if (!m_dFileSystemModel->m_allFileSystemNodes.contains(url)) {
        FileSystemNodePointer tmpNode(parent);
        m_dFileSystemModel->m_allFileSystemNodes[url] = tmpNode;
        rwLock->unlock();
        return tmpNode;
    }

    FileSystemNodePointer tmpNode1(m_dFileSystemModel->m_allFileSystemNodes[url]);
    rwLock->unlock();
    return tmpNode1;
}

void FileNode::setChildren(const QHash<DUrl, FileSystemNodePointer> &map, const QList<FileSystemNodePointer> &list, const DAbstractFileInfo::CompareFunction &sortFun, const Qt::SortOrder &order, const bool &isCancel)
{
    rwLock->lockForWrite();
    children = map;
    visibleChildren = list;
    rwLock->unlock();
}

void run()
{
    // 缓存需要批量插入的文件信息列表
    QList<AppFileInfoPointer> backlogFileInfoList;
    QList<AppFileInfoPointer> backlogDirInfoList;
    // 使用计时器避免文件在批量插入列表中等待太久
    QTime timerOfFileList, timerOfDirList;

    auto insertInfoList = [&](int index, const QList<AppFileInfoPointer> &list) {
        DThreadUtil::runInThread(&semaphore, model()->thread(), model(), &FileSystemModel::beginInsertRows,
                                 model()->createIndex(rootNode, 0), index, index + list.count() - 1);

        for (const AppFileInfoPointer &fileInfo : list) {
            FileSystemNodePointer node = model()->createNode(rootNode.data(), fileInfo);
            rootNode->insertChildren(index++, fileInfo->m_url, node);
        }

        DThreadUtil::runInThread(&semaphore, model()->thread(), model(), &FileSystemModel::endInsertRows);
    };

    auto disposeBacklogFileList = [&] {
        if (backlogFileInfoList.isEmpty())        
            return true;        

        int row = rootNode->childrenCount();
        if (!insertInfoList(row, backlogFileInfoList))
            return false;

        backlogFileInfoList.clear();
        return true;
    };

    auto disposeBacklogDirList = [&] {
        if (backlogDirInfoList.isEmpty())        
            return true;        

        int row = 0;
        forever
        {
            if (row >= rootNode->childrenCount())
                break;            

            const FileSystemNodePointer &node = rootNode->getNodeByIndex(row);
            if (node->fileInfo->m_fileInfo->isFile())
                break;            
            ++row;
        }

        if (!insertInfoList(row, backlogDirInfoList))
            return false;

        backlogDirInfoList.clear();
        return true;
    };

    auto removeInList = [&](QList<AppFileInfoPointer> &list, const DUrl & url) {
        for (int i = 0; i < list.count(); ++i) {
            if (list.at(i)->m_url == url) {
                list.removeAt(i);
                return true;
            }
        }
        return false;
    };

    QList<FileSystemNodePointer> visibleChildren;
    QHash<DUrl, FileSystemNodePointer> children;
    DAbstractFileInfo::CompareFunction compareFun{nullptr};
    while (!fileQueue.isEmpty()) {
        const QPair<EventType, AppFileInfoPointer> &v = dequeueFileQueue();
        const AppFileInfoPointer &fileInfo = v.second;
        if (visibleChildren.isEmpty() && !isFileQueueEmpty()) {
            visibleChildren = rootNode->getChildrenList();
            children = rootNode->getChildrenMap();
        }
        if (!fileInfo) {
            continue;
        }
        const DUrl &fileUrl = fileInfo->m_url;

        if (v.first == AddFile || v.first == AppendFile) {
            if (rootNode->childContains(fileUrl))
                continue;

            int row = -1;

            if (fileInfo->m_fileInfo->hasOrderly() && model()->enabledSort()) {
                if (!compareFun)
                    compareFun = fileInfo->m_fileInfo->compareFunByColumn(model()->sortRole());
                FileSystemNodePointer node = model()->createNode(rootNode.data(), fileInfo);
                row = 0;

                    if (tempjobFinisded && (!isFileQueueEmpty() || !visibleChildren.isEmpty())) {
                        bool cancel = enable;
                        children[fileInfo->m_url] = node;
                        visibleChildren.append(node);
                        if (isFileQueueEmpty()) {
                            model()->sortByMySelf(visibleChildren, compareFun);
                            rootNode->setChildren(children, visibleChildren,
                                                  compareFun, model()->sortOrder(), cancel);
                        } else {
                            continue;
                        }
                    } else {
                       row = rootNode->insertChildren(fileInfo->m_url, node, compareFun, model()->sortOrder());
                    }
            }

            if (row < 0) {
                bool isFile = fileInfo->m_fileInfo->isFile();

                // 先加到待插入列表
                if (isFile) {
                    if (backlogFileInfoList.isEmpty()) {
                        timerOfFileList.start();
                    } else if (timerOfFileList.elapsed() > 1000) {
                        disposeBacklogFileList();
                        timerOfFileList.start();
                    }

                    backlogFileInfoList << fileInfo;
                } else {
                    if (backlogDirInfoList.isEmpty()) {
                        timerOfDirList.start();
                    } else if (timerOfDirList.elapsed() > 1000) {
                        disposeBacklogDirList();
                        timerOfDirList.start();
                    }

                    backlogDirInfoList << fileInfo;
                }
            } else {
                int refreshRow = row;
                int refreshEndRow = row;
                // 搜索目录还是走以前的逻辑
                if (isFileQueueEmpty()) {
                    refreshRow = 0;
                    refreshEndRow = rootNode->childrenCount() - 1;
                } else if (tempjobFinisded && !isFileQueueEmpty()){
                    continue;
                }

                DThreadUtil::runInThread(&semaphore, model()->thread(), model(), &FileSystemModel::beginInsertRows,
                                         model()->createIndex(rootNode, 0), refreshRow, refreshEndRow);
                DThreadUtil::runInThread(&semaphore, model()->thread(), model(), &FileSystemModel::endInsertRows);
            }
        } else {
            // 先尝试从待插入列表中删除
            if (fileInfo->m_fileInfo->isFile()) {
                if (removeInList(backlogFileInfoList, fileUrl))
                    continue;                
            } else if (removeInList(backlogDirInfoList, fileUrl)) {
                continue;
            }

            int row = rootNode->indexOfChild(fileUrl);
            if (row>=0 && DThreadUtil::runInThread(&semaphore, model()->thread(), model(), &FileSystemModel::beginRemoveRows,
                                         model()->createIndex(rootNode, 0), row, row)) {
                Q_UNUSED(rootNode->takeNodeByIndex(row));
                DThreadUtil::runInThread(&semaphore, model()->thread(), model(), &FileSystemModel::endRemoveRows);
            }
        }
    }

    // 退出前确保所有文件都被处理
    disposeBacklogFileList();
    disposeBacklogDirList();
}

FileSystemModelPrivate::FileSystemModelPrivate(FileSystemModel *qq)
    : q_ptr(qq)
    , needQuitUpdateChildren(false)
{
    _q_processFileEvent_runing.store(false);

    columnCompact = DFMApplication::instance()->appAttribute(DFMApplication::AA_ViewComppactMode).toBool();

    qq->connect(rootNodeManager, &FileNodeManagerThread::finished, qq, [this, qq] {
        // 在此线程结束时判断是否需要将model的状态设置为空闲
        if (!jobController || !jobController->isRunning())
        {
            qq->setState(FileSystemModel::Idle);
        }
        //当遍历文件的耗时超过JobController::m_timeCeiling时，
        //onJobFinished函数中拿到的文件不足，因为rootNodeManager还要处理剩余文件
        //因此在这里rootNodeManager处理完后，再次发送信号 关联bug#24863
        emit qq->sigJobFinished();
    });
}

FileSystemModelPrivate::~FileSystemModelPrivate()
{
    if (_q_processFileEvent_runing.load()) {
        fileEventQueue.clear();
    }
}

bool FileSystemModelPrivate::checkFileEventQueue()
{
    mutex.lock();
    bool isemptyqueue = fileEventQueue.isEmpty();
    mutex.unlock();
    return !isemptyqueue;
}

FileSystemModel::FileSystemModel(DFileViewHelper *parent)
    : QAbstractItemModel(parent)
    , d_ptr(new FileSystemModelPrivate(this))
{
    qRegisterMetaType<State>(QT_STRINGIFY(State));
    qRegisterMetaType<DAbstractFileInfoPointer>(QT_STRINGIFY(DAbstractFileInfoPointer));

    m_smForDragEvent = new QSharedMemory();
}

FileSystemModel::~FileSystemModel()
{
    Q_D(FileSystemModel);

    d->needQuitUpdateChildren = true;

    if (m_smForDragEvent) {
        delete m_smForDragEvent;
        m_smForDragEvent = nullptr;
    }

    QMutexLocker locker(&m_mutex); // 必须等待其他 资源性线程结束，否则 要崩溃

    if (d->updateChildrenFuture.isRunning()) {
        d->updateChildrenFuture.cancel();
        d->updateChildrenFuture.waitForFinished();
    }

    d->needQuitUpdateChildren = false;
    QMutexLocker lk(&d_ptr->mutexFlags);
}

DFileViewHelper *FileSystemModel::parent() const
{
    return static_cast<DFileViewHelper *>(QAbstractItemModel::parent());
}

QModelIndex FileSystemModel::index(const DUrl &fileUrl, int column)
{
    Q_D(FileSystemModel);

    if (!fileUrl.isValid())
        return QModelIndex();

    if (fileUrl == rootUrl()) {
        return createIndex(d->rootNode, column);
    }

    if (!d->rootNode) {
        return QModelIndex();
    }

    const FileSystemNodePointer &node = d->rootNode->getNodeByUrl(fileUrl);

    if (!node) {
        return QModelIndex();
    }

    QModelIndex idx = createIndex(node, column);

    return idx;
}

QModelIndex FileSystemModel::index(int row, int column, const QModelIndex &parent) const
{
    Q_D(const FileSystemModel);

    if (row < 0 || column < 0/* || row >= rowCount(parent) || column >= columnCount(parent)*/) {
        return QModelIndex();
    }

    const FileSystemNodePointer &parentNode = parent.isValid()
                                              ? FileSystemNodePointer(getNodeByIndex(parent))
                                              : d->rootNode;

    if (!parentNode) {
        return QModelIndex();
    }

    FileNode *childNode = parentNode->getNodeByIndex(row).data();

    if (!childNode) {
        return QModelIndex();
    }

    return createIndex(row, column, childNode);
}

QModelIndex FileSystemModel::parent(const QModelIndex &child) const
{
    const FileSystemNodePointer &indexNode = getNodeByIndex(child);

    if (!indexNode || !indexNode->parent) {
        return QModelIndex();
    }

    FileSystemNodePointer parentNode(indexNode->parent);

    return createIndex(parentNode, 0);
}

int FileSystemModel::rowCount(const QModelIndex &parent) const
{
    Q_D(const FileSystemModel);

    const FileSystemNodePointer &parentNode = parent.isValid()
                                              ? FileSystemNodePointer(getNodeByIndex(parent))
                                              : d->rootNode;

    if (!parentNode) {
        return 0;
    }

    return parentNode->childrenCount();
}

int FileSystemModel::columnCount(const QModelIndex &parent) const
{
    Q_D(const FileSystemModel);

    int columnCount = parent.column() > 0 ? 0 : DEFAULT_COLUMN_COUNT;
    if (!d->rootNode) {
        return columnCount;
    }

    const DAbstractFileInfoPointer &currentFileInfo = d->rootNode->fileInfo->m_fileInfo;

    if (currentFileInfo) {
        columnCount += currentFileInfo->userColumnRoles().count();
    }

    return columnCount;
}

QVariant FileSystemModel::columnNameByRole(int role, const QModelIndex &index) const
{
    Q_D(const FileSystemModel);

//    const AbstractFileInfoPointer &fileInfo = this->fileInfo(index.isValid() ? index : d->activeIndex);
    const DAbstractFileInfoPointer &fileInfo = index.isValid() ? this->fileInfo(index) : d->rootNode->fileInfo->m_fileInfo;

    if (fileInfo) {
        return fileInfo->userColumnDisplayName(role);
    }

    return QVariant();
}

int FileSystemModel::columnWidthByRole(int role) const
{
    Q_D(const FileSystemModel);

    const DAbstractFileInfoPointer &currentFileInfo = d->rootNode->fileInfo;

    if (currentFileInfo) {
        return currentFileInfo->userColumnWidth(role, parent()->parent()->fontMetrics());
    }

    return 140;
}

bool FileSystemModel::columnDefaultVisibleForRole(int role, const QModelIndex &index) const
{
    Q_D(const FileSystemModel);

//    const AbstractFileInfoPointer &fileInfo = this->fileInfo(index.isValid() ? index : d->activeIndex);
    const DAbstractFileInfoPointer &fileInfo = index.isValid() ? this->fileInfo(index) : d->rootNode->fileInfo;

    if (fileInfo) {
        return fileInfo->columnDefaultVisibleForRole(role);
    }

    return true;
}

bool FileSystemModel::hasChildren(const QModelIndex &parent) const
{
    if (!parent.isValid()) { // drives
        return false;
    }

    const FileSystemNodePointer &indexNode = getNodeByIndex(parent);

    return indexNode && isDir(indexNode);
}

QVariant FileSystemModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid() || index.model() != this) {
        return QVariant();
    }

    const FileSystemNodePointer &indexNode = getNodeByIndex(index);

    if (!indexNode) {
        return QVariant();
    }

    switch (role) {
    case Qt::EditRole:
    case Qt::DisplayRole: {
        int column_role = columnToRole(index.column());

        const QVariant &d = data(index.sibling(index.row(), 0), column_role);

        if (d.canConvert<QString>()) {
            return d;
        } else if (d.canConvert<QPair<QString, QString>>()) {
            return qvariant_cast<QPair<QString, QString>>(d).first;
        } else if (d.canConvert<QPair<QString, QPair<QString, QString>>>()) {
            return qvariant_cast<QPair<QString, QPair<QString, QString>>>(d).first;
        }

        return d;
    }
    case FilePathRole:
    case FileDisplayNameRole:
    case FileNameRole:
    case FileNameOfRenameRole:
    case FileBaseNameRole:
    case FileBaseNameOfRenameRole:
    case FileSuffixRole:
    case FileSuffixOfRenameRole:
        return indexNode->dataByRole(role);
    case FileIconRole:
        if (index.column() == 0) {
            return indexNode->fileInfo->fileIcon();
        }
        break;
    case Qt::TextAlignmentRole:
    case FileLastModifiedRole:
    case FileLastModifiedDateTimeRole:
    case FileSizeRole:
    case FileSizeInKiloByteRole:
    case FileMimeTypeRole:
    case FileCreatedRole:
    case FilePinyinName:
        return indexNode->dataByRole(role);
    case Qt::ToolTipRole: {
        const QList<int> column_role_list = parent()->columnRoleList();

        if (column_role_list.length() < 2) {
            break;
        }

        const QPoint &cursor_pos = parent()->parent()->mapFromGlobal(QCursor::pos());
        QStyleOptionViewItem option;

        option.init(parent()->parent());
        parent()->initStyleOption(&option, index);
        option.rect = parent()->parent()->visualRect(index);
        const QList<QRect> &geometries = parent()->itemDelegate()->paintGeomertys(option, index);

        // 从1开始是为了排除掉icon区域
        for (int i = 1; i < geometries.length() && i <= column_role_list.length(); ++i) {
            const QRect &rect = geometries.at(i);

            if (rect.left() <= cursor_pos.x() && rect.right() >= cursor_pos.x()) {
                const QString &tooltip = data(index, columnActiveRole(i - 1)).toString();

                if (option.fontMetrics.width(tooltip, -1, static_cast<int>(Qt::Alignment(index.data(Qt::TextAlignmentRole).toInt()))) > rect.width()) {
                    return tooltip;
                } else {
                    break;
                }
            }
        }

        return QString();
    }
    case ExtraProperties:
        return indexNode->dataByRole(role);
    case FileIconModelToolTipRole: { // fix bug 202007010029 由于 list 视图处理 tooltip 的代码通用性太弱，所以这里新增一个 role 用来返回 tooltip
        /*fix bug 63708 tooltip应该显示的是显示的名字，不是实际的名字*/
        QString strToolTip = data(index, Qt::DisplayRole).toString();
        QStyleOptionViewItem option;

        option.init(parent()->parent());
        parent()->initStyleOption(&option, index);
        option.rect = parent()->parent()->visualRect(index);
        const QList<QRect> &geometries = parent()->itemDelegate()->paintGeomertys(option, index);
        if (geometries.count() < 3)
            return QString();
        if (option.fontMetrics.width(strToolTip) > geometries[1].width() * 2) {
            return strToolTip;
        }
        return QString();
    }

    default: {
        const DAbstractFileInfoPointer &fileInfo = indexNode->fileInfo;

        return fileInfo->userColumnData(role);
    }
    }

    return QVariant();
}

QVariant FileSystemModel::headerData(int column, Qt::Orientation, int role) const
{
    Q_D(const FileSystemModel);

    if (role == Qt::DisplayRole) {
        int column_role = columnToRole(column);

        if (column_role < FileUserRole) {
            return roleName(column_role);
        } else {
//            const AbstractFileInfoPointer &fileInfo = this->fileInfo(d->activeIndex);
            const DAbstractFileInfoPointer &fileInfo = d->rootNode->fileInfo;

            if (fileInfo) {
                if (fileInfo->columnIsCompact()) {
                    const QList<int> roles = fileInfo->userColumnChildRoles(column);

                    if (!roles.isEmpty()) {
                        column_role = d->columnActiveRole.value(column, roles.first());
                    }
                }

                return fileInfo->userColumnDisplayName(column_role);
            }

            return QVariant();
        }
    }

    return QVariant();
}

QString FileSystemModel::roleName(int role)
{
    switch (role) {
    case FileDisplayNameRole:
    case FileNameRole:
        return tr("Name");
    case FileLastModifiedRole:
        return tr("Time modified");
    case FileSizeRole:
        return tr("Size");
    case FileMimeTypeRole:
        return tr("Type");
    case FileCreatedRole:
        return tr("Time created");
    case FileLastReadRole:
        return tr("Last access");
    case FilePathRole:
        return tr("Path");
    default:
        return QString();
    }
}

int FileSystemModel::columnToRole(int column) const
{
    Q_D(const FileSystemModel);

    if (!d->rootNode)
        return UnknowRole;

    const DAbstractFileInfoPointer &fileInfo = d->rootNode->fileInfo;

    if (fileInfo) {
        //获取修改过顺序后的列属性
        DUrl url = rootUrl();
        const QVariantMap &map = DFMApplication::appObtuselySetting()->value("FileViewState", url).toMap();
        if (map.contains("headerList")) {
            const QVariantList &indexList = map.value("headerList").toList();
            if (indexList.length() > column)
                return indexList.at(column).toInt();
        }

        return fileInfo->userColumnRoles().value(column, UnknowRole);
    }

    return UnknowRole;
}

int FileSystemModel::roleToColumn(int role) const
{
    Q_D(const FileSystemModel);

    if (!d->rootNode) {
        return -1;
    }

//        const AbstractFileInfoPointer &fileInfo = this->fileInfo(d->activeIndex);
    const DAbstractFileInfoPointer &fileInfo = d->rootNode->fileInfo;

    if (fileInfo) {
        int column = fileInfo->userColumnRoles().indexOf(role);
        DUrl url = rootUrl();
        //获取修改过顺序后的列属性的索引
        const QVariantMap &map = DFMApplication::appObtuselySetting()->value("FileViewState", url).toMap();
        if (map.contains("headerList")) {
            const QVariantList &indexList = map.value("headerList").toList();
            if (indexList.length() > column)
                column = indexList.indexOf(role);
        }

        if (column < 0) {
            return -1;
        }

        return column;
    }

    return -1;
}

void FileSystemModel::fetchMore(const QModelIndex &parent)
{
    Q_D(FileSystemModel);

    if (d->eventLoop || !d->rootNode)
        return;

    const FileSystemNodePointer &parentNode = getNodeByIndex(parent);

    if (!parentNode || parentNode->populatedChildren)
        return;

    if (d->sortFuture.isRunning()) {
        d->sortFuture.cancel();
        d->sortFuture.waitForFinished();
    }

    /// make root file to active
    d->rootNode->fileInfo->m_fileInfo->makeToActive();
    parentNode->populatedChildren = true;

    setState(Busy);

    //TODO add files
    d->childrenUpdated = false;
}

Qt::ItemFlags FileSystemModel::flags(const QModelIndex &index) const
{
    Q_D(const FileSystemModel);
    Qt::ItemFlags flags = QAbstractItemModel::flags(index);
    if (!index.isValid())
        return flags;

    if (rootUrl() == "app:///")
        flags |= Qt::ItemIsDropEnabled;

    const FileSystemNodePointer &indexNode = getNodeByIndex(index);

    if (!indexNode)
        return flags;

    flags |= Qt::ItemIsDragEnabled;

    if ((index.column() == 0)) {
        if (d->readOnly)
            return flags;              
    } else {
        flags = flags & ~Qt::ItemIsSelectable;
    }
    return flags & ~ indexNode->fileInfo->m_fileInfo->fileItemDisableFlags();
}

Qt::DropActions FileSystemModel::supportedDragActions() const
{
    Q_D(const FileSystemModel);
    return Qt::CopyAction;
}

Qt::DropActions FileSystemModel::supportedDropActions() const
{
    Q_D(const FileSystemModel);

    if (rootUrl() == "app:///")
        return Qt::CopyAction;

    return Qt::IgnoreAction;
}

QStringList FileSystemModel::mimeTypes() const
{
    return QStringList(QLatin1String("text/uri-list"));
}

bool FileSystemModel::dropMimeData(const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &parent)
{
//    qDebug() << "drop mime data";
    Q_UNUSED(row);
    Q_UNUSED(column);
    if (!parent.isValid() || rootUrl() != "app:///") {
        return false;
    }

    bool success = true;
    const FileSystemNodePointer &node = getNodeByIndex(parent);
    if(!node) return false;

    DUrl toUrl = node->fileInfo->m_url;
    DUrlList urlList = DUrl::fromQUrlList(data->urls());

    if(toUrl.host().isEmpty()) {
        DUrlList l;
        for(auto u : urlList)
            if(u.fileName().endsWith(".deb"))
                l.append(u);

        if(!l.isEmpty()) fileService->openFiles(this, l);
        return true;
    }

    toUrl = DUrl::fromLocalFile(node->fileInfo->m_file);
    const DAbstractFileInfoPointer &info = fileService->createFileInfo(this, toUrl);

    if (info->isSymLink()) {
        toUrl = info->rootSymLinkTarget();
    }

    if (DFMGlobal::isTrashDesktopFile(toUrl)) {
        //FIXME add uninstall apps
        toUrl = DUrl::fromTrashFile("/");
        fileService->moveToTrash(this, urlList);
        return true;
    } else if (DFMGlobal::isComputerDesktopFile(toUrl)) {
        return true;
    } else if (DFMGlobal::isDesktopFile(toUrl)) {
        return FileUtils::launchApp(toUrl.toLocalFile(), DUrl::toStringList(urlList));
    }

    return success;
}

QMimeData *FileSystemModel::mimeData(const QModelIndexList &indexes) const
{
    QList<QUrl> urls;
    QSet<QUrl> urls_set;

    if(rootUrl() == "app:///") {
        QList<QModelIndex>::const_iterator it = indexes.begin();

        for (; it != indexes.end(); ++it) {
            if ((*it).column() == 0) {
                const DAbstractFileInfoPointer &fileInfo = this->fileInfo(*it);
                const QUrl &url = fileInfo->mimeDataUrl();

                if (urls_set.contains(url)) {
                    continue;
                }

                urls << url;
                urls_set << url;
            }
        }
    }

    QMimeData *data = new QMimeData();

    // 主目录下多个库目录禁止拖拽, 只要包含目录即禁止, 用户目录相关
    if (urls.isEmpty()) {
        QByteArray isProhibit(ISDRAGPROHIBIT);
        data->setData(MIME_PROHIBIT_DRAG, isProhibit);
    }

    DFMGlobal::setMimeDataUserID(data);
    data->setUrls(urls);
    qInfo() << data->data(MIME_USER_ID);
//    data->setText(urls.first().path());
//    data->setData("forDragEvent", urls.first().toEncoded());
//    FOR_DRAGEVENT = urls;
//    qDebug() << "Set FOR_DRAGEVENT urls FOR_DRAGEVENT count = " << FOR_DRAGEVENT.length();
    m_smForDragEvent->setKey(DRAG_EVENT_URLS);
    //qDebug() << DRAG_EVENT_URLS;
    if (m_smForDragEvent->isAttached()) {
        if (!m_smForDragEvent->detach()) {
            return data;
        }
    }
    QBuffer buffer;
    buffer.open(QBuffer::ReadWrite);
    QDataStream out(&buffer);
    out << urls;
    //int size = static_cast<int>(buffer.size());
    //fix task 21485 分配一个固定的5M内存
    bool bcanwrite = m_smForDragEvent->create(5 * 1024 * 1024);
    if (bcanwrite || m_smForDragEvent->error() == QSharedMemory::AlreadyExists) {
        //因为创建失败，就没有连接内存，所以写失败
        if (!bcanwrite) {
            m_smForDragEvent->attach();
        }
        m_smForDragEvent->lock();
        char *to = static_cast<char *>(m_smForDragEvent->data());
        const char *from = buffer.data().data();
        memcpy(to, from, qMin(static_cast<size_t>(buffer.size()), static_cast<size_t>(m_smForDragEvent->size())));
        m_smForDragEvent->unlock();
        qDebug() << " write mem finish. " << m_smForDragEvent->errorString() << m_smForDragEvent->size();
    }
    return data;
}

bool FileSystemModel::canFetchMore(const QModelIndex &parent) const
{
    const FileSystemNodePointer &parentNode = getNodeByIndex(parent);
    return parentNode && !parentNode->populatedChildren;
}

QModelIndex FileSystemModel::setRootUrl(const DUrl &fileUrl, const QString &path)
{
    Q_D(FileSystemModel);
    // Restore state
    setState(Idle);

    if (d->eventLoop)
        d->eventLoop->exit(1);

    if (d->updateChildrenFuture.isRunning()) {
        // 使用QFuture::cancel() 函数无效，定义个变量控制线程的退出
        d->updateChildrenFuture.cancel();
        d->updateChildrenFuture.waitForFinished();
    }

    if (d->rootNode)
        clear();

    d->rootNode = createNode(Q_NULLPTR, AppFileInfo(fileUrl, path, this), &d->rootNodeRWLock);
    d->columnActiveRole.clear();

    return index(fileUrl);
}

DUrl FileSystemModel::rootUrl() const
{
    Q_D(const FileSystemModel);

    return d->rootNode ? d->rootNode->fileInfo->fileUrl() : DUrl();
}

DUrlList FileSystemModel::sortedUrls()
{
    Q_D(const FileSystemModel);
    if (!d->rootNode) {
        return DUrlList();
    }
    return d->rootNode->getChildrenUrlList();
}

DUrlList FileSystemModel::getNoTransparentUrls()
{
    DUrlList lst = sortedUrls();
    DUrlList lstValid;
    for (DUrl url : lst) {
        QModelIndex idx = index(url);
        if (!idx.isValid())
            continue;
        if (parent()->isTransparent(idx))
            continue;
        lstValid << url;
    }
    return lstValid;
}

DUrl FileSystemModel::getUrlByIndex(const QModelIndex &index) const
{
    const FileSystemNodePointer &node = getNodeByIndex(index);
    if (!node) {
        return DUrl();
    }

    return node->fileInfo->fileUrl();
}

void FileSystemModel::setSortColumn(int column, Qt::SortOrder order)
{
    int role = columnActiveRole(column);
    setSortRole(role, order);
}

void FileSystemModel::setSortRole(int role, Qt::SortOrder order)
{
    Q_D(FileSystemModel);

    d->sortRole = role;
    d->srotOrder = order;
}

Qt::SortOrder FileSystemModel::sortOrder() const
{
    Q_D(const FileSystemModel);

    return d->srotOrder;
}

void FileSystemModel::setSortOrder(const Qt::SortOrder &order)
{
    Q_D(FileSystemModel);
    d->srotOrder = order;
}

int FileSystemModel::sortColumn() const
{
    Q_D(const FileSystemModel);

    if (!d->rootNode || !d->rootNode->fileInfo) {
        return -1;
    }

    if (d->rootNode->fileInfo->columnIsCompact()) {
        int i = 0;

        for (const int role : d->rootNode->fileInfo->userColumnRoles()) {
            if (role == d->sortRole) {
                return i;
            }

            const QList<int> childe_roles = d->rootNode->fileInfo->userColumnChildRoles(i);

            if (childe_roles.indexOf(d->sortRole) >= 0) {
                return i;
            }

            ++i;
        }
    }

    return roleToColumn(d->sortRole);
}

int FileSystemModel::sortRole() const
{
    Q_D(const FileSystemModel);

    return d->sortRole;
}

void FileSystemModel::sort(int column, Qt::SortOrder order)
{
    Q_D(FileSystemModel);

    int old_sortRole = d->sortRole;
    int old_sortOrder = d->srotOrder;

    setSortColumn(column, order);

    if (old_sortRole == d->sortRole && old_sortOrder == d->srotOrder) {
        return;
    }

    sort();
}

bool FileSystemModel::sort()
{
    return sort(true);
}

bool FileSystemModel::sort(bool emitDataChange)
{
    Q_D(FileSystemModel);

    if (!enabledSort()) {
        return false;
    }

    if (state() == Busy) {
        qWarning() << "I'm busying";

        return false;
    }

    if (QThreadPool::globalInstance()->activeThreadCount() >= MAX_THREAD_COUNT) {
        qDebug() << "Beyond the maximum number of threads!";
        return false;
    }

    if (QThread::currentThread() == qApp->thread()) {
        d->sortFuture = QtConcurrent::run(QThreadPool::globalInstance(), this, &FileSystemModel::sort);

        return false;
    }

    return  doSortBusiness(emitDataChange);
}

bool FileSystemModel::doSortBusiness(bool emitDataChange)
{
    Q_D(const FileSystemModel);
    QMutexLocker locker(&m_mutex);
    const FileSystemNodePointer &node = d->rootNode;

    if (!node) return false;

    QList<FileSystemNodePointer> list;
    bool ok = sort(node->fileInfo, list);

    if (ok) {
        if (!list.isEmpty())
            node->setChildrenList(list);
        if (emitDataChange)
            emitAllDataChanged();        
    }

    emit sortFinished();
    return ok;
}

const DAbstractFileInfoPointer FileSystemModel::fileInfo(const QModelIndex &index) const
{
    const FileSystemNodePointer &node = getNodeByIndex(index);
    return node ? node->fileInfo->m_fileInfo : DAbstractFileInfoPointer();
}

const DAbstractFileInfoPointer FileSystemModel::fileInfo(const DUrl &fileUrl) const
{
    Q_D(const FileSystemModel);

    if (!d->rootNode) {
        return DAbstractFileInfoPointer();
    }

    if (fileUrl == d->rootNode->fileInfo->m_url) {
        return d->rootNode->fileInfo->m_fileInfo;
    }

    const FileSystemNodePointer &node = d->rootNode->getNodeByUrl(fileUrl);

    return node ? node->fileInfo->m_fileInfo : DAbstractFileInfoPointer();
}

const DAbstractFileInfoPointer FileSystemModel::parentFileInfo(const QModelIndex &index) const
{
    const FileSystemNodePointer &node = getNodeByIndex(index);

    return node ? node->parent->fileInfo->m_fileInfo : DAbstractFileInfoPointer();
}

const DAbstractFileInfoPointer FileSystemModel::parentFileInfo(const DUrl &fileUrl) const
{
    Q_D(const FileSystemModel);
    if (fileUrl == rootUrl() || fileUrl.path() == "/") {
        return d->rootNode->fileInfo->m_fileInfo;
    }

    return fileService->createFileInfo(this, fileUrl.parentUrl(fileUrl));
}

FileSystemModel::State FileSystemModel::state() const
{
    Q_D(const FileSystemModel);

    return d->state;
}

void FileSystemModel::setReadOnly(bool readOnly)
{
    Q_D(FileSystemModel);

    d->readOnly = readOnly;
}

bool FileSystemModel::isReadOnly() const
{
    Q_D(const FileSystemModel);

    return d->readOnly;
}

bool FileSystemModel::enabledSort() const
{
    Q_D(const FileSystemModel);

    return d->enabledSort;
}

bool FileSystemModel::setColumnCompact(bool compact)
{
    Q_D(FileSystemModel);

    if (d->columnCompact == compact) {
        return false;
    }

    d->columnCompact = compact;

    if (d->rootNode) {
        if (d->rootNode->fileInfo) {
            d->rootNode->fileInfo->m_fileInfo->setColumnCompact(compact);
        }

        for (const FileSystemNodePointer &child : d->rootNode->getChildrenList()) {
            child->fileInfo->m_fileInfo->setColumnCompact(compact);
        }
    }

    return true;
}

bool FileSystemModel::columnIsCompact() const
{
    Q_D(const FileSystemModel);

    if (d->rootNode && d->rootNode->fileInfo) {
        return d->rootNode->fileInfo->m_fileInfo->columnIsCompact();
    }

    return d->columnCompact;
}

void FileSystemModel::setColumnActiveRole(int column, int role)
{
    Q_D(FileSystemModel);

    d->columnActiveRole[column] = role;
}

int FileSystemModel::columnActiveRole(int column) const
{
    Q_D(const FileSystemModel);

    if (!d->rootNode || !d->rootNode->fileInfo) {
        return UnknowRole;
    }

    if (!d->rootNode->fileInfo->m_fileInfo->columnIsCompact()) {
        return columnToRole(column);
    }

    const QList<int> &roles = d->rootNode->fileInfo->m_fileInfo->userColumnChildRoles(column);

    if (roles.isEmpty()) {
        return columnToRole(column);
    }

    return d->columnActiveRole.value(column, roles.first());
}

void FileSystemModel::updateChildren(QList<DAbstractFileInfoPointer> list)
{
    Q_D(FileSystemModel);

//    qDebug() << "Begin update chidren. file list count " <<  list.count();
    const FileSystemNodePointer &node = d->rootNode;

    if (!node) {
        return;
    }

    node->clearChildren();

    QHash<DUrl, FileSystemNodePointer> fileHash;
    QList<FileSystemNodePointer> fileList;

    fileHash.reserve(list.size());
    fileList.reserve(list.size());

    for (const DAbstractFileInfoPointer &fileInfo : list) {
        if (!fileInfo) {
            continue;
        }

        const FileSystemNodePointer &chileNode = createNode(node.data(), fileInfo);
        //当文件路径和名称都相同的情况下，fileHash在赋值，会释放，fileList保存的普通指针就是悬空指针
        if (!fileHash[fileInfo->fileUrl()]) {
            fileHash[fileInfo->fileUrl()] = chileNode;
            fileList << chileNode;
        }
    }
    if (enabledSort())
        sort(node->fileInfo, fileList);

    beginInsertRows(createIndex(node, 0), 0, list.count() - 1);
    node->setChildrenMap(fileHash);
    node->setChildrenList(fileList);
    endInsertRows();
}

void FileSystemModel::updateChildrenOnNewThread(QList<DAbstractFileInfoPointer> list)
{
    Q_D(FileSystemModel);
    QMutexLocker locker(&m_mutex);

    if (QThreadPool::globalInstance()->activeThreadCount() >= QThreadPool::globalInstance()->maxThreadCount()) {
        QThreadPool::globalInstance()->setMaxThreadCount(QThreadPool::globalInstance()->maxThreadCount() + 10);
    }

    d->updateChildrenFuture = QtConcurrent::run(QThreadPool::globalInstance(), this, &FileSystemModel::updateChildren, list);
}

void FileSystemModel::refresh(const DUrl &fileUrl)
{
    Q_D(const FileSystemModel);

    if (d->state != Idle)
        return;

    const FileSystemNodePointer &node = d->rootNode;

    if (!node) {
        return;
    }

    if (!fileUrl.isEmpty() && fileUrl != rootUrl()) {
        return;
    }

    node->populatedChildren = false;

    const QModelIndex &index = createIndex(node, 0);
   	beginRemoveRows(index, 0, rowCount(index) - 1);
    node->clearChildren();
    endRemoveRows();

    fetchMore(index);
}

void FileSystemModel::update()
{
    Q_D(const FileSystemModel);

    const QModelIndex &rootIndex = createIndex(d->rootNode, 0);

    for (const FileSystemNodePointer &node : d->rootNode->getChildrenList()) {
        if (node->fileInfo && node->fileInfo->m_fileInfo)
            node->fileInfo->m_fileInfo->refresh();
    }

    emit dataChanged(rootIndex.child(0, 0), rootIndex.child(rootIndex.row() - 1, 0));
}

void FileSystemModel::setEnabledSort(bool enabledSort)
{
    Q_D(FileSystemModel);

    if (d->enabledSort == enabledSort) {
        return;
    }

    d->enabledSort = enabledSort;
    emit enabledSortChanged(enabledSort);
}

bool FileSystemModel::removeRows(int row, int count, const QModelIndex &parent)
{
    Q_D(FileSystemModel);

    const FileSystemNodePointer &parentNode = parent.isValid() ? getNodeByIndex(parent) : d->rootNode;
    if (parentNode && parentNode->populatedChildren) {
        const DAbstractFileInfoPointer &fileInfo = this->fileInfo(index(row, 0));
        fileInfo->refresh();
        if (fileInfo->exists())
            return true;
       	
        beginRemoveRows(createIndex(parentNode, 0), row, row + count - 1);
        for (int i = 0; i < count; ++i) {
            Q_UNUSED(parentNode->takeNodeByIndex(row));
        }
        endRemoveRows();      
    }

    return true;
}

bool FileSystemModel::remove(const DUrl &url)
{
    Q_D(FileSystemModel);
    const FileSystemNodePointer &parentNode = d->rootNode;

    if (parentNode && parentNode->populatedChildren) {
        int index = parentNode->indexOfChild(url);
        if (index < 0) 
            return false;
        
        beginRemoveRows(createIndex(parentNode, 0), index, index);
        Q_UNUSED(parentNode->takeNodeByIndex(index));
        endRemoveRows();

        return true;
    }
    return false;
}

const FileSystemNodePointer FileSystemModel::getNodeByIndex(const QModelIndex &index) const
{
    Q_D(const FileSystemModel);

    if (!d->rootNode) {
        return FileSystemNodePointer();
    }

    FileNode *indexNode = static_cast<FileNode *>(index.internalPointer());

    if (!indexNode) {
        return FileSystemNodePointer();
    }

    if (indexNode == d->rootNode.constData()) {
        return d->rootNode;
    }

    if (d->rootNode->getNodeByIndex(index.row()).data() != indexNode
            || indexNode->ref <= 0) {
        return FileSystemNodePointer();
    }

    return FileSystemNodePointer(indexNode);
}

QModelIndex FileSystemModel::createIndex(const FileSystemNodePointer &node, int column) const
{
    int row = (node->parent && node->parent->childrenCount() > 0)
              ? node->parent->indexOfChild(node)
              : 0;

    return createIndex(row, column, const_cast<FileNode *>(node.data()));
}

bool FileSystemModel::isDir(const FileSystemNodePointer &node) const
{
    return !node->fileInfo->m_fileInfo || node->fileInfo->m_fileInfo->isDir();
}

bool FileSystemModel::sort(const AppFileInfoPointer &parentInfo, QList<FileSystemNodePointer> &list) const
{
    Q_D(const FileSystemModel);

    if (!parentInfo) return false;

    DAbstractFileInfo::CompareFunction sortFun = parentInfo->m_fileInfo->compareFunByColumn(d->sortRole);

    if (!sortFun)
        return false;

    if (list.isEmpty() && d->rootNode) {
        d->rootNode->sortAllChildren(sortFun, d->sortOrder);
    } else {
        const_cast<FileSystemModel*>(this)->sortByMySelf(list, sortFun);
    }

    if (columnIsCompact() && d->rootNode && d->rootNode->fileInfo) {
        int column = 0;

        for (int role : d->rootNode->fileInfo->m_fileInfo->userColumnRoles()) {
            if (role == d->sortRole)
                return true;            

            if (d->rootNode->fileInfo->m_fileInfo->userColumnChildRoles(column).indexOf(d->sortRole) >= 0) {
                const_cast<FileSystemModel *>(this)->setColumnActiveRole(column, d->sortRole);
            }

            ++column;
        }
    }

    return true;
}

const FileSystemNodePointer FileSystemModel::createNode(FileNode *parent, const AppFileInfoPointer &info, QReadWriteLock *lock)
{
    Q_ASSERT(info);
    Q_D(const FileSystemModel);
    QString url(info->m_file);
    if (m_allFileSystemNodes.contains(url) && d->rootNode) {
        qDebug() << "recreate node url = " << url;
        d->rootNode->removeFileSystemNode(m_allFileSystemNodes[url]);
    }

    FileSystemNodePointer node(new FileNode(parent, info, this, lock));

    if(node->fileInfo->m_fileInfo)
        node->fileInfo->m_fileInfo->setColumnCompact(d->columnCompact);

    return node;
}

void FileSystemModel::deleteNode(const FileSystemNodePointer &node)
{
    if(node->fileInfo->m_fileInfo)
        node->fileInfo->m_fileInfo->makeToInactive();
}

void FileSystemModel::clear()
{
    Q_D(const FileSystemModel);

    if (!d->rootNode)
        return;    

    QMutexLocker locker(&m_mutex); // bug 26972, while the sort case is ruuning, there should be crashed ASAP, so add locker here!

    const QModelIndex &index = createIndex(d->rootNode, 0);
    beginRemoveRows(index, 0, d->rootNode->childrenCount() - 1);
    deleteNode(d->rootNode);
    endRemoveRows();    
}

void FileSystemModel::setState(FileSystemModel::State state)
{
    Q_D(FileSystemModel);

    if (d->state == state) {
        return;
    }

    d->state = state;

    emit stateChanged(state);
}

void FileSystemModel::addFile(const AppFileInfoPointer &fileInfo)
{
    Q_D(const FileSystemModel);

    const FileSystemNodePointer parentNode = d->rootNode;
    const DUrl &fileUrl = fileInfo->m_url;

    FileSystemNodePointer node = createNode(parentNode.data(), fileInfo);

    if (parentNode->childContains(fileUrl))
        return;

    if (parentNode && parentNode->populatedChildren) {
        int row = -1;

        if (d->enabledSort) {
            row = 0;

            QFuture<void> result;

            // tmp: 暂时不排序 排序的宏在大量添加文件操作时会崩（最近访问目录不存在大量文件添加的情况 可放开）
            if (fileInfo->m_fileInfo->hasOrderly()) {
                result = QtConcurrent::run(QThreadPool::globalInstance(), [&] {
                    DAbstractFileInfo::CompareFunction compareFun = fileInfo->m_fileInfo->compareFunByColumn(d->sortRole);
                    DUrl tempUrl = fileUrl;
                    FileSystemNodePointer tempNode = node;
                    Qt::SortOrder order = d->sortOrder;
                    row = d->rootNode->insertChildren(tempUrl, tempNode, compareFun, order, false);
                });
            }

            while (!result.isFinished()) {
                qApp->processEvents();
            }
        }

        if (m_allFileSystemNodes.contains(fileInfo->m_file)) {
            qDebug() << "File already exist url = " <<  fileInfo->m_file;
            return;
        }

        beginInsertRows(createIndex(parentNode, 0), row == -1 ? parentNode->childrenCount() : row,
                        row == -1 ? parentNode->childrenCount() : row);

        parentNode->insertChildren(row == -1 ? parentNode->childrenCount() : row, fileUrl, node);

        endInsertRows();
    }
}

void FileSystemModel::emitAllDataChanged()
{
    Q_D(const FileSystemModel);

    if (!d->rootNode) {
        return;
    }

    QModelIndex parentIndex = createIndex(d->rootNode, 0);
    QModelIndex topLeftIndex = index(0, 0, parentIndex);
    QModelIndex rightBottomIndex = index(d->rootNode->childrenCount(), columnCount(parentIndex), parentIndex);

    QMetaObject::invokeMethod(this, "dataChanged", Qt::QueuedConnection,
                              Q_ARG(QModelIndex, topLeftIndex), Q_ARG(QModelIndex, rightBottomIndex));
}

void FileSystemModel::sortByMySelf(QList<FileSystemNodePointer> &list, const DAbstractFileInfo::CompareFunction &sortFun)
{
    Q_D(FileSystemModel);
    QList<FileSystemNodePointer> sortList;
    int row = 0;
    for (const auto & needNode : list) {
        row = FindInsertPosInOrderList(needNode, sortList, sortFun, d->srotOrder);
        sortList.insert(row, needNode);
    }
    list = sortList;
}

#include "moc_dfilesystemmodel.cpp"


